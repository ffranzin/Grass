
#include "Assets/GrassVariables.cginc"

#pragma kernel ComputeObjectCollision
#pragma kernel InitializeCollisionPage
#pragma kernel RecoverCollisionPageToInitialState


//Maintain this values below matching with the enum 'ShapeType' in 'ColllisionShape.cs'.
#define COLLIDER_PLANE 0
#define COLLIDER_SPHERE 1


#define RECOVERED_DIRECTION float3(0.0, 1.0, 0.0)
RWTexture2D<float4> _collisionmapAtlas;
RWTexture2D<float> _heightmapAtlas;
float4 _OriginOffset;
float _deltaTime;

float3 _forceDir;

float4 _Plane_Vertices[4];
float3 _Plane_Normal;
float3 _Plane_Position;
float3 _Sphere_Position;

float _collisionRecoverSpeed;

int _positionsBufferCounter;

float _objectRadius;
float3 _colliderPosition;

int _generateStaticColision;
int _colliderShape;
float4 _boundMin;
float4 _boundMax;

StructuredBuffer<float4> _positionsBuffer;

StructuredBuffer<float4> _collisionPages;

#include "ObjectCollisionDetectUtils.cginc"


#define RECOVER_SPEED 1


[numthreads(8, 8, 1)]
void InitializeCollisionPage(uint3 id : SV_DispatchThreadID)
{
    if (id.x > _collisionmapDesc.z || id.y > _collisionmapDesc.z)
        return;
		
	_collisionmapAtlas[_collisionmapDesc.xy + id.xy] = float4(RECOVERED_DIRECTION, INFINITY);
}


float BilinearHeightMap(float2 atlasPosHM)
{
	float tl = _heightmapAtlas.Load(int3(atlasPosHM, 0)).r;   
    float tr = _heightmapAtlas.Load(int3(atlasPosHM + float2(1, 0), 0)).r;   
    float bl = _heightmapAtlas.Load(int3(atlasPosHM + float2(0, 1), 0)).r;   
    float br = _heightmapAtlas.Load(int3(atlasPosHM + float2(1, 1), 0)).r; 
        
    float2 fracPos = frac(atlasPosHM);    
	float t = lerp(tl, tr, fracPos.x);
	float b = lerp(bl, br, fracPos.x);

	return lerp(t, b, fracPos.y);
}


void FindCollisionPos(float3 grassVector, float2 atlasPos, float3 wPos, float currentSpeed)
{
	float3 grassDir = normalize(grassVector);
	float mag = length(grassVector);
	float distance = INFINITY;

	float3 colisionPos = float3(0,0,0);

	float speed = _collisionRecoverSpeed * 0.1;

	//////////////////////////
	//FIND COLISION DISTANCE//
	//////////////////////////
	if(_colliderShape == COLLIDER_PLANE)
	{
		distance = RayPlaneIntersect(wPos, grassDir, _Plane_Position, _Plane_Normal);
		colisionPos = wPos + grassDir * distance;
		
		if(!PointInsideArbitraryQuad(colisionPos, _Plane_Vertices))
			distance = INFINITY;
		else
			speed = 0;
	}
	else if(_colliderShape == COLLIDER_SPHERE)
	{
		distance = RaySphereIntersect(wPos, grassDir, _Sphere_Position, _objectRadius);

		colisionPos = wPos + grassDir * distance;

		if(length(colisionPos.xz - _Sphere_Position.xz) > _objectRadius)
			distance = INFINITY;
		else
			speed = 0;
	}
	
	

	//////////////////////////
	//FIND NEW COLISION POS //
	//////////////////////////
	if(distance <= mag)
	{
		float h_offset = colisionPos.y - wPos.y;

		float d = sqrt((mag * mag) - (h_offset * h_offset));

		float3 pointOutOfObject = colisionPos + normalize(_forceDir) * d;

		grassVector = normalize(pointOutOfObject - wPos) * mag;
	}
	
	_collisionmapAtlas[atlasPos] = float4(grassVector, 0);
}




[numthreads(8,8,1)]
void ComputeObjectCollision(uint3 id : SV_DispatchThreadID)
{
    float2 pos = id.xy + _boundMin.xy;

    if (pos.x > _collisionmapDesc.z || pos.y > _collisionmapDesc.z)
        return;

    float2 uv = saturate(pos / _collisionmapDesc.z);

	float2 wp = _cellWorldDesc.xy + _cellWorldDesc.zw * uv.xy;
	float3 worldPos = float3(wp.x, 0, wp.y);
	
	float2 atlasPos = round(_collisionmapDesc.xy + uv * _collisionmapDesc.z);

	float4 collisionSample = _collisionmapAtlas[atlasPos];

	float2 atlasPosHM = _heightmapAtlasDesc.xy +  (uv * (_heightmapAtlasDesc.z - 2));
	
	if(!IsPointInsideCircle(worldPos.xz + collisionSample.xz, _colliderPosition.xz, _objectRadius))
	{
		_collisionmapAtlas[atlasPos] = float4(collisionSample.xyz, _collisionRecoverSpeed);
		return;
	}

	worldPos.y = 0.05;// BilinearHeightMap(atlasPosHM);
	
	FindCollisionPos(collisionSample.xyz, atlasPos, worldPos, collisionSample.w);
}



inline int2 GetCollisionPageMin(uint3 id)	{return _collisionPages[id.z].xy;}
inline int GetCollisionPageSize(uint3 id)	{return _collisionPages[id.z].z;}



float3 MyInterpolation(float3 v1, float3 v2, float increment)
{
	float v2_mag = length(v2);

	v1 = normalize(v1);
	v2 = normalize(v2);

	v2 = v2 + normalize(v1 - v2) * increment * _deltaTime;
	
	return normalize(v2) * v2_mag;
}



[numthreads(8, 8, 1)]
void RecoverCollisionPageToInitialState(uint3 id : SV_DispatchThreadID)
{
    if (id.x > GetCollisionPageSize(id) || id.y > GetCollisionPageSize(id))
        return;

    float2 atlasPos = GetCollisionPageMin(id) + id.xy;
	
	float4 sample = _collisionmapAtlas[atlasPos];

	if(sample.w < 0.00001)	return;

    float mag = length(sample.xyz);

	float3 dir = normalize(sample.xyz);

	float speed = sample.w + 0.1;

	if(dot(RECOVERED_DIRECTION, dir) < 0.999)	
		sample.xyz = MyInterpolation(RECOVERED_DIRECTION, dir, speed);
	
	_collisionmapAtlas[atlasPos] = sample;
}	

