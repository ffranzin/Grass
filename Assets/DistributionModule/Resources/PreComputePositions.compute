

#pragma kernel ComputePositions

#include "Assets\NoisesShader\Resources\SimplexNoise2D.cginc"
#include "Assets\NoisesShader\Resources\NoiseUtils.cginc"
#include "Assets\NoisesShader\Resources\ClassicNoise2D.cginc"
#include "Assets\DistributionModule\Resources\GrassUtils.cginc"
#include "Assets\GrassVariables.cginc"

//AppendStructuredBuffer<float4> _positionsBuffer;

float4 _gridDim;
float4 _cellDesc;
float4 _positionsBufferDesc;
int _distribuitionSeed;

RWTexture2D<float4> _positionsBufferAtlas;


inline float2 CellMin()		{return _cellDesc.xy;}
inline float2 CellSize()	{return _cellDesc.zw;}


[numthreads(8,8,1)]
void ComputePositions(uint3 id : SV_DispatchThreadID)
{
	if(id.x > _gridDim.x || id.y > _gridDim.x)	return;
	
	float2 uv = saturate(id.xy / _gridDim.x);

	float halfCellSize = _gridDim.y * .5;

	float2 displacement = float2(halfCellSize, halfCellSize) /*Translate to center of gridCell*/ 
						+ (RandomPosInsideSquere((uv * _distribuitionSeed), id.x) * halfCellSize);
	
	float2 posWorld = CellMin() + uv * CellSize() + displacement;

	//posWorld = CellMin() + RandomPosInsideSquere((id.xy * _distribuitionSeed), 1) * CellSize();

	float scale = max(0.5, abs(gradientfbm2D(posWorld % 100, 2, 2, 1, 0.5, 2)));
	
	_positionsBufferAtlas[id.xy + _positionsBufferDesc.xy] = float4(posWorld.x, 0, posWorld.y, scale);
}




/*

[numthreads(8,8,1)]
void ComputePositions1(uint3 id : SV_DispatchThreadID)
{
	if(id.x > _gridDim.x || id.y > _gridDim.x)	return;
	
	float2 uv = saturate(id.xy / _gridDim.x);

	float halfCellSize = _gridDim.y * .5;

	float2 displacement = float2(halfCellSize, halfCellSize) 
						+ (RandomPosInsideSquere((uv * _distribuitionSeed) % 100, id.x) * halfCellSize);
	
	float2 posWorld = uv * _cellDesc.zw;
	posWorld += _cellDesc.xy;

	float scale = max(0.5, abs(gradientfbm2D(posWorld % 100, 2, 2, 1, 0.5, 2)));
	
	if(scale > SCALE_CUTOFF)
		_positionsBuffer.Append(float4(posWorld.x, 0, posWorld.y, scale));
}
*/