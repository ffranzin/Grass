// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeLODs

#include "Assets/GrassVariables.cginc"

float3 _cameraPosition;

StructuredBuffer<float4> _allPagesDesc;

int _allPagesDescCounter;

Texture2D<float4> _positionsBufferAtlas;

AppendStructuredBuffer<float4> _outputPositionsBuffer_LOD0;
AppendStructuredBuffer<float4> _outputPositionsBuffer_LOD1;
AppendStructuredBuffer<float4> _outputPositionsBuffer_LOD2;
StructuredBuffer<float> _LODRanges;



inline void AddPositionOnBufferLOD(float4 position)
{
	float distance = length(_cameraPosition - position.xyz);
	
	if(distance < _LODRanges[0])		_outputPositionsBuffer_LOD0.Append(position);
	else if(distance < _LODRanges[1])	_outputPositionsBuffer_LOD1.Append(position);
	else if(distance < _LODRanges[2])	_outputPositionsBuffer_LOD2.Append(position);
}


[numthreads(8,8,4)]
void ComputeLODs(uint3 id : SV_DispatchThreadID)
{
	if( id.x > _allPagesDesc[id.z].z || id.y > _allPagesDesc[id.z].z || id.z > _allPagesDescCounter)	return;
	
	AddPositionOnBufferLOD(_positionsBufferAtlas[id.xy + _allPagesDesc[id.z].xy]);
}





[numthreads(8,8,1)]
void ComputeLODs1(uint3 id : SV_DispatchThreadID)
{
	int k = 4;

	int ini = id.z * k;
	int end = ini + k;
	
	for(int i = ini; i < end; i++)
	{
		if( id.x > _allPagesDesc[id.z].z || id.y > _allPagesDesc[id.z].z || id.z > _allPagesDescCounter)	return;
		
		AddPositionOnBufferLOD(_positionsBufferAtlas[id.xy + _allPagesDesc[i].xy]);
	}
}


